/*
==============================================================================

  This file was auto-generated by the Introjucer!

  It contains the basic startup code for a Juce application.

==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
PitchedDelayAudioProcessorEditor::PitchedDelayAudioProcessorEditor (PitchedDelayAudioProcessor* ownerFilter)
  : AudioProcessorEditor (ownerFilter),
		tabs(TabbedButtonBar::TabsAtTop, ownerFilter)
{
	LookAndFeel::setDefaultLookAndFeel(&lookAndFeel);

	addAndMakeVisible(&tabs);
	tabs.setTabBarDepth(25);

	for (int i=0; i<NUMDELAYTABS; ++i)
	{
		const String tabName("Delay Tap " + String(i+1));
		PitchedDelayTab* delay = new PitchedDelayTab(getProcessor(), i);
		delays.add(delay);
		tabs.addTab(tabName, Colour(0xFFC0C0C0), delays.getLast(), false);
		delay->addActionListener(this);
	}

	addAndMakeVisible(graph = new DelayGraph(delays, ownerFilter));

	addAndMakeVisible(&dryVolume);
	dryVolume.setRange(-60, 12, 0.1);
	dryVolume.setSliderStyle(Slider::LinearVertical);
	dryVolume.setTextBoxStyle(Slider::TextBoxBelow, false, 50, 20);
	dryVolume.addListener(this);

	addAndMakeVisible(&masterVolume);
	masterVolume.setRange(-60, 12, 0.1);
	masterVolume.setSliderStyle(Slider::LinearVertical);
	masterVolume.setTextBoxStyle(Slider::TextBoxBelow, false, 50, 20);
	masterVolume.addListener(this);

	addAndMakeVisible(&showTooltips);
	showTooltips.setButtonText("Show tooltips");
	showTooltips.addListener(this);

	tooltipWindow = new TooltipWindow();

	setSize (600, 390);

	startTimer(100);
}

PitchedDelayAudioProcessorEditor::~PitchedDelayAudioProcessorEditor()
{

}


void PitchedDelayAudioProcessorEditor::resized()
{
	graph->setBounds(0, 0, 600, 100);
	tabs.setBounds(0, 100, 500, 380);
	dryVolume.setBounds(502, 120, 46, 245);
	masterVolume.setBounds(552, 120, 46, 245);
	showTooltips.setBounds(502, 370, 96, 20);
}

//==============================================================================
void PitchedDelayAudioProcessorEditor::paint (Graphics& g)
{
  g.fillAll (Colour(0xFFB0B0B0));
	g.setFont(Font(14.f));
	g.setColour(Colours::black);
	g.drawText("Dry", 500, 100, 50, 20, Justification::centred, false);
	g.drawText("Master", 550, 100, 50, 20, Justification::centred, false);
}

void PitchedDelayAudioProcessorEditor::timerCallback()
{
	PitchedDelayAudioProcessor* Proc = getProcessor();

	const int currentTab = Proc->currentTab;

	if (currentTab != tabs.getCurrentTabIndex() && currentTab >= 0)
		tabs.setCurrentTabIndex(currentTab, false);


	dryVolume.setValue(12. + Decibels::gainToDecibels(Proc->getParameter(Proc->getNumDelayParameters() + PitchedDelayAudioProcessor::kDryVolume)));
	masterVolume.setValue(12. + Decibels::gainToDecibels(Proc->getParameter(Proc->getNumDelayParameters() + PitchedDelayAudioProcessor::kMasterVolume)));

	showTooltips.setToggleState(Proc->showTooltips, false);

	if (Proc->showTooltips && tooltipWindow == nullptr)
		tooltipWindow = new TooltipWindow();
	else if (! Proc->showTooltips && tooltipWindow != nullptr)
		tooltipWindow = 0;
}

void PitchedDelayAudioProcessorEditor::actionListenerCallback(const String& message)
{
	PitchedDelayAudioProcessor* Proc = getProcessor();

	StringArray cmds;
	const int numCmds = cmds.addTokens(message, ":", "");

	if (numCmds == 3 && cmds[0].startsWith("Tab"))
	{		
		const String tab(cmds[0]);
		const String param(cmds[1]);
		const String val(cmds[2]);

		const int delayIdx = tab.substring(3).getIntValue();
		const double value = val.getDoubleValue();
		int paramIdx = -1;

		DelayTabDsp* dsp = Proc->getDelay(delayIdx);
		jassert(dsp != 0);

		if (param == "Delay")
		{
			paramIdx = DelayTabDsp::kDelay;
		}
		else if (param == "Sync")
		{
			paramIdx = DelayTabDsp::kSync;
		}
		else if (param == "Pitch")
		{
			paramIdx = DelayTabDsp::kPitch;
		}
		else if (param == "PitchType")
		{
			paramIdx = DelayTabDsp::kPitchType;
		}
		else if (param == "Feedback")
		{
			paramIdx = DelayTabDsp::kFeedback;
		}
		else if (param == "EqFreq")
		{
			paramIdx = DelayTabDsp::kFilterFreq;
		}
		else if (param == "EqQ")
		{
			paramIdx = DelayTabDsp::kFilterQ;
		}
		else if (param == "EqGain")
		{
			paramIdx = DelayTabDsp::kFilterGain;
		}
		else if (param == "Volume")
		{
			paramIdx = DelayTabDsp::kVolume;
		}
		else if (param == "EqType")
		{
			paramIdx = DelayTabDsp::kFilterType;
		}
		else if (param == "PrePitch")
		{
			paramIdx = DelayTabDsp::kPrePitch;
		}
		else if (param == "Enabled")
		{
			paramIdx = DelayTabDsp::kEnabled;
		}
		else if (param == "Mode")
		{
			paramIdx = DelayTabDsp::kMode;
		}
		else
		{
			jassertfalse;
		}

		if (paramIdx >= 0)
		{
			const int procParem = paramIdx + delayIdx * DelayTabDsp::kNumParameters;
			Proc->setParameterNotifyingHost(procParem, dsp->plainToNormalized(paramIdx, value));
		}

	}
}

void PitchedDelayAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
	PitchedDelayAudioProcessor* Proc = getProcessor();

	if (slider == &dryVolume)
	{
		Proc->setParameterNotifyingHost(Proc->getNumDelayParameters() + PitchedDelayAudioProcessor::kDryVolume, Decibels::decibelsToGain((float) dryVolume.getValue() - 12.f));
	}
	else if (slider == &masterVolume)
	{
		Proc->setParameterNotifyingHost(Proc->getNumDelayParameters() + PitchedDelayAudioProcessor::kMasterVolume, Decibels::decibelsToGain((float) masterVolume.getValue() - 12.f));
	}
}

void PitchedDelayAudioProcessorEditor::buttonClicked (Button* button)
{
	if (button == &showTooltips)
	{
		getProcessor()->showTooltips = showTooltips.getToggleState();
	}
}
